====== DNSSEC ======

=== Q1. What does a validating resolver do?  ===

It works the same way as a normal resolver,
but has the DNSSEC added.
This means that it will verify the queries it sends by
checking the RRSIG on the DNSKEY and verify the RRSIG for the DS record.
The hash of the DS (located at parent) should match the public KSK
of the zone (child) one is querying.
All to verify that the chain of trust is not altered.

=== Q2. Add support for DNSSEC to your BIND or Unbound configuration  ===
== a. What changes do you have to make to your configuration?  == 

DNSSEC enabled in named.conf:
<code>
options {
directory "/usr/local/etc/bind";
//For dns labs we want recursion, for mail labs we do not
//recursion no;
allow-recursion { 0/0; };
fetch-glue yes;
//DNSSEC lab
dnssec-enable yes;
dnssec-validation auto;
};
//the auto will get the root DNSKEY (KSK=257) for us
//managed-keys {};
</code>
Bind can do 'managed-keys' itself when validation is set to auto.

== b. Verify the root key used against a trusted source  == 

We first get the keys:
<code>
dig DNSKEY . \
  @d.root-servers.net \
  +noall +answer \
  > /tmp/root.key
</code>

Now we verify:
<code>
root@nevers:~/bind# docker exec -it bind_bind_1 bash
bash-4.4# dnssec-dsfromkey -f /tmp/root.key -2 .
. IN DS 19036 8 2 49AAC11D7B6F6446702E54A1607371607A1A41855200FD2CE1CDDE32F24E8FB5
. IN DS 20326 8 2 E06D44B80B8F1D39A95C0B0D7C65D08458E880409BBC683457104237C7F8EC8D
</code>
Which matches [[https://data.iana.org/root-anchors/root-anchors.xml|data.iana.org/...xml]]


=== Q3. Use dig or drill to verify the validity of DNS records for isc org and os3 nl Show the results  ===

<code>
root@nevers:~/bind# dig os3.nl. @145.100.104.117 +dnssec

; <<>> DiG 9.11.3-1ubuntu1.2-Ubuntu <<>> os3.nl. @145.100.104.117 +dnssec
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 48134
;; flags: qr rd ra ad; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags: do; udp: 4096
; COOKIE: 493682ef4eb3a9aae5a572ba5bbc44c23d2414f60ea8a98e (good)
;; QUESTION SECTION:
;os3.nl.                                IN      A

;; ANSWER SECTION:
os3.nl.                 21600   IN      A       145.100.96.70
os3.nl.                 21600   IN      RRSIG   A 5 2 21600 20181107180929 20181008180929 42048 os3.nl. p+tyj9b/6HtX6Yx05y670ZrU5i71AzHr4v7285QQUBHL1A5KOOSD3q9S GPRch/iUe2zuSYSXJQy/aeLuKikoKhEGZrPGqtKFSwo39UD5yue5EpBU s8cHrgwq010PzPpJc4KzRP6/7e9Xq4qHTNw2WkbXvG5B41mwZtKrlmG4 7sc=

;; Query time: 840 msec
;; SERVER: 145.100.104.117#53(145.100.104.117)
;; WHEN: Tue Oct 09 08:03:46 CEST 2018
;; MSG SIZE  rcvd: 245
</code>

<code>
root@nevers:~/bind# dig isc.org. @145.100.104.117 +dnssec               

; <<>> DiG 9.11.3-1ubuntu1.2-Ubuntu <<>> isc.org. @145.100.104.117 +dnssec
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 34734
;; flags: qr rd ra ad; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags: do; udp: 4096
; COOKIE: 4957dc002cc096f0cc575d1c5bbc44f801dbfe82dd2611ab (good)
;; QUESTION SECTION:
;isc.org.                       IN      A

;; ANSWER SECTION:
isc.org.                60      IN      A       149.20.64.69
isc.org.                60      IN      RRSIG   A 5 2 60 20181107233627 20181008233627 19923 isc.org. X9RdA1T3FmMfzQvVbWkxQ7KLP2pl2U/nDoZFTL0MrTIjWgPzH9BdMmbF OxZbAFgNn//w2IgAHS7dSCwZOQQcmj5xJP9dkekh0jewfpbalLY7EhIl xtXGMteGYpN9e4BWwbPiKmH/5iT3/GXvbeo2B0Hh90waQ2xTKetpjuv/ at4=

;; Query time: 548 msec
;; SERVER: 145.100.104.117#53(145.100.104.117)
;; WHEN: Tue Oct 09 08:04:40 CEST 2018
;; MSG SIZE  rcvd: 247
</code>

=== Q4. How does dig / drill show whether DNSSEC validation was succesful or not?  ===

<code>
man dig| grep -A 3 adflag
       +[no]adflag
           Set [do not set] the AD (authentic data) bit in the query.
           This requests the server to return whether all of the
           answer and authority sections have all been validated as
</code>
So we look for this flag.

<code>
dig lent.ink. @145.100.104.117 +dnssec|grep flags|head -1
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
</code>
Which is correct,
since IANA [[https://www.icann.org/resources/pages/deployment-2012-02-25-en|tells me]]
that my domain provider (NameSilo) does not provide DNSSEC for .ink.

Further analysis:
<code>
root@nevers:~/bind# dig uva.nl. @145.100.104.117 +dnssec|grep flags|head -1
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
root@nevers:~/bind# dig google.com. @145.100.104.117 +dnssec|grep flags|head -1                                                                 
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
root@nevers:~/bind# dig os3.nl. @145.100.104.117 +dnssec|grep flags|head -1
;; flags: qr rd ra ad; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1
</code>
even Google has no DNSSEC, which I verified
[[https://dnssec-analyzer.verisignlabs.com/google.com|online]].


=== Q5. Where does BIND/Unbound store the DNSSEC root key?  ===

<code>
bash-4.4# ls -al|grep keys
-rw-r--r--    1 root     root          2761 Sep 28 14:51 bind.keys
-rw-r--r--    1 root     root          1421 Oct  9 05:47 managed-keys.bind
-rw-r--r--    1 root     root          2430 Oct  9 05:47 managed-keys.bind.jnl
</code>
As we seen earlier in the config, this is the same name as the config option managed-keys.

=== Q6. How do managed keys differ from trusted keys ? Which RFC describes the mechanisms for managed keys?  ===

<code>
bash-4.4# cat managed-keys.bind
$ORIGIN .
$TTL 0  ; 0 seconds
@                       IN SOA  . . (
                                2          ; serial
                                0          ; refresh (0 seconds)
                                0          ; retry (0 seconds)
                                0          ; expire (0 seconds)
                                0          ; minimum (0 seconds)
                                )
                        KEYDATA 20181010054715 20181009054715 19700101000000 257 3 8 (
                                AwEAAagAIKlVZrpC6Ia7gEzahOR+9W29euxhJhVVLOyQ
                                bSEW0O8gcCjFFVQUTf6v58fLjwBd0YI0EzrAcQqBGCzh
                                /RStIoO8g0NfnfL2MTJRkxoXbfDaUeVPQuYEhg37NZWA
                                JQ9VnMVDxP/VHL496M/QZxkjf5/Efucp2gaDX6RS6CXp
                                oY68LsvPVjR0ZSwzz1apAzvN9dlzEheX7ICJBBtuA6G3
                                LQpzW5hOA2hzCTMjJPJ8LbqF6dsV6DoBQzgul0sGIcGO
                                Yl7OyQdXfZ57relSQageu+ipAdTTJ25AsRTAoub8ONGc
                                LmqrAmRLKBP1dfwhYB4N7knNnulqQxA+Uk1ihz0=
                                ) ; KSK; alg = RSASHA256; key id = 19036
                                ; next refresh: Wed, 10 Oct 2018 05:47:15 GMT
                                ; trusted since: Tue, 09 Oct 2018 05:47:15 GMT
                        KEYDATA 20181010054715 20181009054715 19700101000000 257 3 8 (
                                AwEAAaz/tAm8yTn4Mfeh5eyI96WSVexTBAvkMgJzkKTO
                                iW1vkIbzxeF3+/4RgWOq7HrxRixHlFlExOLAJr5emLvN
                                7SWXgnLh4+B5xQlNVz8Og8kvArMtNROxVQuCaSnIDdD5
                                LKyWbRd2n9WGe2R8PzgCmr3EgVLrjyBxWezF0jLHwVN8
                                efS3rCj/EWgvIWgb9tarpVUDK/b58Da+sqqls3eNbuv7
                                pr+eoZG+SrDK6nWeL3c6H5Apxz7LjVc1uTIdsIXxuOLY
                                A4/ilBmSVIzuDWfdRUfhHdY6+cn8HFRm+2hM8AnXGXws
                                9555KrUB5qihylGa8subX2Nn6UwNR1AkUTV74bU=
                                ) ; KSK; alg = RSASHA256; key id = 20326
                                ; next refresh: Wed, 10 Oct 2018 05:47:15 GMT
                                ; trusted since: Tue, 09 Oct 2018 05:47:15 GMT
</code>

RFC5011 describes the managed-keys,
which can be auto-updated,
which we see in the file (next refresh).
Trusted keys are updated manually (or you can script it..).

=== Q7. How did you modify the DNSSEC root key?  ===

Replacing all '/' in base64 with an 'a':
<code>
cp managed-keys.bind managed-keys.bind.bak
sed -i 's/\//a/g' managed-keys.bind
</code>

Reloaded named:
<code>
docker-compose restart bind
</code>

=== Q8. What problems did your server encounter and how did it react?  ===

<code>
root@nevers:~/bind# dig os3.nl. @145.100.104.117 +dnssec|grep flags|head -1
;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1
root@nevers:~/bind# dig os3.nl. @145.100.104.117 +dnssec

; <<>> DiG 9.11.3-1ubuntu1.2-Ubuntu <<>> os3.nl. @145.100.104.117 +dnssec
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: SERVFAIL, id: 10833
;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags: do; udp: 4096
; COOKIE: 347680a0d3bd536a391e73055bbc4c5068d08788541e038b (good)
;; QUESTION SECTION:
;os3.nl.                                IN      A

;; Query time: 1 msec
;; SERVER: 145.100.104.117#53(145.100.104.117)
;; WHEN: Tue Oct 09 08:36:00 CEST 2018
;; MSG SIZE  rcvd: 63
</code>

We got ourself a SERVFAIL.

=== Q9. Look up which cryptographic algorithms are available for use in DNSSEC Which one do you prefer and why?  ===

<code>
curl --silent https://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.txt \
  | grep -A 6 Reserved | head -20
      4    Reserved                                                         [RFC6725]
      5    RSA/SHA-1                      RSASHA1               Y      Y    [RFC3110][RFC4034]
      6    DSA-NSEC3-SHA1                 DSA-NSEC3-SHA1        Y      Y    [RFC5155][proposed standard]
      7    RSASHA1-NSEC3-SHA1             RSASHA1-NSEC3-SHA1    Y      Y    [RFC5155][proposed standard]
      8    RSA/SHA-256                    RSASHA256             Y      *    [RFC5702][proposed standard]
      9    Reserved                                                         [RFC6725]
     10    RSA/SHA-512                    RSASHA512             Y      *    [RFC5702][proposed standard]
     11    Reserved                                                         [RFC6725]
     12    GOST R 34.10-2001              ECC-GOST              Y      *    [RFC5933][standards track]
     13    ECDSA Curve P-256 with SHA-256 ECDSAP256SHA256       Y      *    [RFC6605][standards track]
     14    ECDSA Curve P-384 with SHA-384 ECDSAP384SHA384       Y      *    [RFC6605][standards track]
     15    Ed25519                        ED25519               Y      *    [RFC8080][standards track]
     16    Ed448                          ED448                 Y      *    [RFC8080][standards track]
   17-122  Unassigned
   123-251 Reserved                                                         [RFC4034][RFC6014]
     252   Reserved for Indirect Keys     INDIRECT              N      N    [RFC4034][proposed standard]
     253   private algorithm              PRIVATEDNS            Y      Y    [RFC4034]
     254   private algorithm OID          PRIVATEOID            Y      Y    [RFC4034]
     255   Reserved                                                         [RFC4034][proposed standard]

curl --silent https://tools.ietf.org/id/draft-sury-dnskey-ed25519-02.xml|grep -A 2 targeted
      <t>Ed25519 is targeted to provide attack resistance comparable
      to quality 128-bit symmetric ciphers that is equivalent
      strength of RSA with 3072-bit keys.  Public keys are 256 bits
--
      <t>Ed448 is targeted to provide attack resistance comparable
      to quality 224-bit symmetric ciphers that is equivalent
      strength of RSA with ~12448-bit keys.  However only RSA with
--
      <t>Ed25519 is targeted to provide attack resistance comparable
      to quality 128-bit symmetric ciphers, and Ed448 is targeted to
      provide attack resistance comparable to quality 224-bit
      symmetric ciphers.  Such an assessment could, of course, change

</code>
RFC8080 is the newest, we'll go for ED22519 since 128-bit is sufficient for our use case
(we are not an online bank).

=== Q10. In practice different algorithms key sizes and key lifetimes are chosen for KSKs and ZSKs Discuss what are these differences in  ===
== a. algorithms  == 
== b. key sizes  == 
== c. key lifetimes  == 


=== Q11. Choose appropriate algorithms key sizes and key lifetimes for your KSK and ZSK  ===

=== Q12. Show the signed version of your zone file How does it differ from the unsigned version? Any unexpected differences?  ===

=== Q13. Which DS record do you need to send to Niels and why that one? Once Niels has implemented your DS record use a DNSSEC debugger to examine the chain of trust see http //dnssec-debugger verisignlabs com/ (use more detail ) or http //dnsviz net/  ===

=== Q14. Show the results of the examination of your secured domain  ===

=== Q15. Describe the DS and DNSKEY records from os3 nl down that are important for your domain Which keys are used to sign them?  ===

=== Q16. Start planning for a Zone Signing Key rollover  ===
== a. Describe the options for doing a ZSK rollover make a motivated choice for one procedure  == 
== b. How do you implement this procedure with the tools for signing your zone?  == 
== c. Which timers are important for this procedure?  == 
== d. Implement the procedure and use a DNSSEC debugger to verify each step Don't forget to show the results of each verification  == 

=== Q17. Can you use the same procedure for a KSK rollover? What does this depend on?  ===


==== BONUS ====

=== Q18. Integrity is important because you want your buddy to include the right DS records Is confidentiality also an issue? Explain  ===

=== Q19. Verify the integrity of your buddy's resource records using dig or drill Is the ad flag set?  ===

=== Q20. What are the main differences between NSEC and NSEC3?  ===

=== Q21. Does the root use NSEC or NSEC3? What about the org domain?  ===

=== Q22. How common is NSEC3?  ===